package main

import (
	"context"
	"fmt"
	"sync"
	"time"
)

// writer - функция, которая записывает значения в канал
// ctx - контекст для управления временем жизни горутины
// ch - канал ТОЛЬКО для записи (chan<- int)
// wg - WaitGroup для синхронизации завершения горутин
func writer(ctx context.Context, ch chan<- int, wg *sync.WaitGroup) {
	// Убеждаемся, что при выходе из функции:
	// 1. Сообщим WaitGroup, что горутина завершилась
	// 2. Закроем канал (это важно для reader'а)
	defer wg.Done()
	defer close(ch)

	i := 1 // Начинаем отсчет с 1

	// Бесконечный цикл, который будет прерван сигналом от контекста
	for {
		// select позволяет ждать на нескольких каналах одновременно
		select {
		// Проверяем, не пришел ли сигнал отмены от контекста
		// ctx.Done() возвращает канал, который закрывается при отмене контекста
		case <-ctx.Done():
			fmt.Println("Writer: время вышло")
			return // Выходим из функции, что запустит defer'ы выше

		// Пытаемся отправить значение в канал
		// Эта операция блокируется, если канал полон (в нашем случае буфер 10)
		// Если канал не готов принять значение, select будет ждать здесь
		case ch <- i:
			fmt.Printf("Отправлено: %d\n", i)
			i++                                // Увеличиваем счетчик для следующего значения
			time.Sleep(500 * time.Millisecond) // Задержка между отправками
		}
		// Цикл продолжается, пока не получим ctx.Done()
	}
}

// reader - функция, которая читает значения из канала
// ch - канал ТОЛЬКО для чтения (<-chan int)
// wg - WaitGroup для синхронизации завершения горутин
func reader(ch <-chan int, wg *sync.WaitGroup) {
	// Убеждаемся, что при выходе сообщим WaitGroup о завершении
	defer wg.Done()

	// Конструкция range ch выполняет итерацию по каналу
	// Она БЛОКИРУЕТ выполнение, пока в канале есть данные или канал не закрыт
	// Цикл автоматически завершится, когда канал будет закрыт writer'ом
	for value := range ch {
		fmt.Printf("Получено: %d\n", value)
	}

	// Этот код выполнится ТОЛЬКО после закрытия канала
	fmt.Println("Reader: канал закрыт")
}

func main() {
	N := 4                // Время работы программы в секундах
	var wg sync.WaitGroup // Создаем WaitGroup для синхронизации горутин

	// Создаем контекст с таймаутом
	// context.Background() - базовый контекст
	// WithTimeout создает контекст, который автоматически отменяется через N секунд
	// cancel - функция для принудительной отмены контекста (не используется здесь,
	// но нужна для правильного освобождения ресурсов)
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(N)*time.Second)

	// defer гарантирует, что cancel() будет вызвана ПРИ ЛЮБОМ выходе из main()
	// Это освобождает ресурсы таймера внутри контекста
	defer cancel()

	// Создаем буферизованный канал емкостью 10
	// Буфер позволяет writer'у отправлять до 10 значений без блокировки,
	// даже если reader еще не успел их прочитать
	datachan := make(chan int, 10)

	fmt.Printf("Программа запущена на %d секунд\n", N)

	// Указываем WaitGroup, что будем ждать завершения 2 горутин
	wg.Add(2)

	// Запускаем writer в отдельной горутине (легковесном потоке)
	// Ключевое слово go означает запуск функции в параллельном потоке выполнения
	go writer(ctx, datachan, &wg)

	// Запускаем reader в отдельной горутине
	go reader(datachan, &wg)

	// <-ctx.Done() БЛОКИРУЕТ выполнение основной горутины (main)
	// до тех пор, пока контекст не будет отменен (через N секунд)
	// Когда таймер сработает, канал ctx.Done() закроется, и выполнение продолжится
	<-ctx.Done()

	// wg.Wait() БЛОКИРУЕТ выполнение, пока счетчик WaitGroup не станет равным 0
	// То есть ждем, пока ВСЕ горутины (writer и reader) не вызовут wg.Done()
	// Это гарантирует, что программа не завершится раньше времени
	wg.Wait()

	fmt.Println("Программа завершена")
	// Здесь функция main завершается, что приводит к завершению ВСЕЙ программы
}
