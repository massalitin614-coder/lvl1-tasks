package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"
)

// Job представляет собой задачу для выполнения воркерами.
// В данном примере содержит только идентификатор, но в реальных
// сценариях может содержать данные для обработки.
type Job struct {
	ID int
}

// producer создает задачи и отправляет их в канал jobs.
// Работает до получения сигнала отмены через контекст.
//
// Параметры:
//   - ctx: контекст для отслеживания сигнала завершения
//   - jobs: канал для отправки созданных задач (только для записи)
//   - wg: WaitGroup для синхронизации завершения горутины
//
// Особенности:
//   - Горутина завершается при отмене контекста
//   - Канал jobs закрывается при завершении работы producer
//   - Идентификаторы задач увеличиваются монотонно
func producer(ctx context.Context, jobs chan<- Job, wg *sync.WaitGroup) {
	// Гарантируем уменьшение счетчика WaitGroup при завершении
	defer wg.Done()
	// Гарантируем закрытие канала при завершении producer
	defer close(jobs)

	id := 1
	for {
		select {
		// Проверяем сигнал отмены контекста
		case <-ctx.Done():
			fmt.Println("Продюсер: Получен сигнал остановки!")
			return
		// Отправляем задачу в канал, если есть возможность
		case jobs <- Job{ID: id}:
			fmt.Printf("Продюсер отправляет задание %d\n", id)
			id++
			// Пауза для эмуляции времени создания задачи
			time.Sleep(100 * time.Millisecond)
		}
	}
}

// worker обрабатывает задачи из канала jobs.
// Работает до получения сигнала отмены или закрытия канала.
//
// Параметры:
//   - ctx: контекст для отслеживания сигнала завершения
//   - workerID: уникальный идентификатор воркера для логгирования
//   - jobs: канал для получения задач (только для чтения)
//   - wg: WaitGroup для синхронизации завершения горутины
//
// Особенности:
//   - Воркер немедленно завершается при получении сигнала отмены
//   - Воркер корректно завершается при закрытии канала jobs
//   - Все задачи, попавшие в канал, будут обработаны перед закрытием
func worker(ctx context.Context, workerID int, jobs <-chan Job, wg *sync.WaitGroup) {
	// Гарантируем уменьшение счетчика WaitGroup при завершении
	defer wg.Done()

	fmt.Printf("Воркер %d стартует\n", workerID)
	// Сообщение о завершении работы при выходе из функции
	defer fmt.Printf("Воркер %d завершает работу\n", workerID)

	for {
		select {
		// Сигнал отмены контекста - немедленный выход
		case <-ctx.Done():
			fmt.Printf("Воркер %d: получен сигнал остановки\n", workerID)
			return
		// Попытка получить задачу из канала
		case job, ok := <-jobs:
			// Если канал закрыт и пуст - завершаем работу
			if !ok {
				fmt.Printf("Воркер %d: канал задач закрыт, завершение работы\n", workerID)
				return
			}

			// Обработка задачи
			fmt.Printf("Воркер %d выполняет работу %d\n", workerID, job.ID)
			// Пауза для эмуляции времени обработки задачи
			time.Sleep(200 * time.Millisecond)
			fmt.Printf("Воркер %d выполнил работу %d\n", workerID, job.ID)
		}
	}
}

// main является точкой входа в программу.
// Настраивает и запускает продюсера и воркеров, обрабатывает graceful shutdown.
//
// Алгоритм работы:
//  1. Создание контекста с отслеживанием сигналов прерывания (Ctrl+C, SIGTERM)
//  2. Создание канала для задач с буфером
//  3. Запуск продюсера для создания задач
//  4. Запуск воркеров для обработки задач
//  5. Ожидание сигнала завершения
//  6. Graceful shutdown всех компонентов
func main() {
	// Создаем контекст, который отменяется при получении сигналов:
	// - os.Interrupt (Ctrl+C)
	// - syscall.SIGTERM (сигнал завершения от системы)
	// Это позволяет корректно обрабатывать graceful shutdown
	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	// Гарантируем, что сигналы будут перехвачены при выходе
	defer stop()

	// Создаем буферизированный канал для задач.
	// Буфер размером 5 позволяет продюсеру создавать задачи немного быстрее,
	// чем воркеры успевают их обрабатывать, сглаживая пики нагрузки.
	jobs := make(chan Job, 5)

	// WaitGroup для ожидания завершения всех горутин
	var wg sync.WaitGroup

	// Запускаем продюсера (создателя задач)
	wg.Add(1)
	go producer(ctx, jobs, &wg)

	// Запускаем воркеров (обработчиков задач)
	numberWorker := 3
	for i := 1; i <= numberWorker; i++ {
		wg.Add(1)
		go worker(ctx, i, jobs, &wg)
	}

	fmt.Println("Запущено: Для выхода нажмите Ctrl+C")
	fmt.Println("Ожидание сигнала завершения...")

	// Ожидаем сигнал завершения через отмену контекста
	// Блокируется до получения сигнала отмены
	<-ctx.Done()
	fmt.Println("\nПолучен сигнал остановки! Начинаем graceful shutdown...")

	// Ожидаем завершения всех горутин:
	// 1. Сначала завершится producer (перестанет создавать задачи и закроет канал)
	// 2. Затем workers обработают все оставшиеся задачи в канале
	// 3. Когда все задачи обработаны, workers завершатся
	wg.Wait()

	fmt.Println("Все горутины завершены. Корректный выход из программы!")
}
