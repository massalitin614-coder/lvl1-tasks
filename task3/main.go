package main

import (
	"flag"      // пакет для чтения параметров командной строки (например: -workers 5)
	"fmt"       // вывод текста в консоль
	"os"        // работа с ОС (нужен для os.Interrupt)
	"os/signal" // ловим сигналы ОС, например Ctrl+C
	"sync"      // WaitGroup для ожидания завершения горутин
	"time"      // задержки (Sleep), работа со временем
)

// worker — функция воркера (горутина).
// Она читает числа из канала ch и печатает их.
// wg нужен, чтобы main мог дождаться завершения всех воркеров.
func worker(id int, ch <-chan int, wg *sync.WaitGroup) {
	// defer выполнится в конце работы функции worker (когда воркер завершится).
	// wg.Done() уменьшает счётчик WaitGroup на 1.
	defer wg.Done()

	// range по каналу читает значения, пока канал не закрыт.
	// Когда канал закрывают (close(ch)), цикл автоматически заканчивается.
	for data := range ch {
		// Имитация "обработки" (воркер делает работу 700 мс).
		time.Sleep(700 * time.Millisecond)

		// Печатаем: какой воркер получил какое значение.
		fmt.Printf("Воркер %d: получил %d\n", id, data)
	}

	// Сюда воркер попадает, когда канал закрыли и данных больше нет.
	fmt.Printf("Воркер %d остановился\n", id)
}

func main() {
	// Читаем параметры командной строки:
	// -workers сколько воркеров создать
	// -buffer размер буфера канала (0 = канал без буфера)
	workers := flag.Int("workers", 3, "количество воркеров")
	buffer := flag.Int("buffer", 0, "размер буфера канала (0 = без буфера)")
	flag.Parse() // запускаем разбор аргументов

	// Проверка входных данных (чтобы не было странных зависаний и ошибок)
	if *workers <= 0 {
		fmt.Println("workers must be > 0")
		return
	}
	if *buffer < 0 {
		fmt.Println("buffer must be >= 0")
		return
	}

	// Создаём канал для передачи данных воркерам.
	// Если buffer = 0, канал без буфера (отправка будет ждать чтения).
	// Если buffer > 0, канал может хранить несколько значений "в очереди".
	ch := make(chan int, *buffer)

	// Канал stop нужен для получения сигнала Ctrl+C.
	stop := make(chan os.Signal, 1)

	// Подписываемся на сигнал прерывания (Ctrl+C).
	signal.Notify(stop, os.Interrupt)

	// Хорошая практика: в конце отписаться от сигналов.
	defer signal.Stop(stop)

	// WaitGroup будет ждать, пока все воркеры завершатся.
	var wg sync.WaitGroup

	// Создаём N воркеров (N = workers).
	for i := 1; i <= *workers; i++ {
		wg.Add(1)             // увеличиваем счётчик "активных воркеров"
		go worker(i, ch, &wg) // запускаем воркера в отдельной горутине
	}

	// Producer (производитель) — работает в ГЛАВНОЙ горутине (main).
	// Он постоянно отправляет данные в канал ch.
	counter := 1
	for {
		select {
		// Если пришёл Ctrl+C — начинаем корректное завершение программы.
		case <-stop:
			fmt.Println("\nCtrl+C получено, выключение...")

			// Закрываем канал: воркеры дочитают оставшиеся значения и выйдут из range.
			// Важно: канал закрывает именно producer (тот, кто пишет в канал).
			close(ch)

			// Ждём, пока все воркеры завершатся (выполнят wg.Done()).
			wg.Wait()

			fmt.Println("Все воркеры остановились, пока!")
			return

		// Обычный режим: отправляем число в канал.
		case ch <- counter:
			fmt.Printf("Отправлено producer'ом: %d\n", counter)
			counter++

			// Producer быстрее воркеров (100мс vs 700мс), чтобы видно было очередь/блокировки.
			time.Sleep(100 * time.Millisecond)
		}
	}
}
