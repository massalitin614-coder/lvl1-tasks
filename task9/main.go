package main

import (
	"context"
	"fmt"
	"time"
)

func main() {
	// Если программа работает дольше 5 секунд - она автоматически прервется
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	// Отложенный вызов cancel() гарантирует освобождение ресурсов контекста
	defer cancel()

	// Исходный массив чисел для обработки
	numSlice := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

	// Создаем три канала:
	oneChan := make(chan int)    // Для исходных чисел
	doubleChan := make(chan int) // Для чисел, умноженных на 2
	done := make(chan struct{})  // Для сигнала завершения всей программы

	// 1: ГЕНЕРАТОР (пишет в первый канал)
	go func() {
		// Гарантируем закрытие канала при выходе из горутины
		defer close(oneChan)

		// Проходим по всем числам в массиве
		for _, value := range numSlice {
			// Используем select для неблокирующей отправки
			// Это позволяет прервать отправку, если контекст отменен
			select {
			case oneChan <- value: // Пытаемся отправить число в канал
			case <-ctx.Done(): // Если контекст отменен (таймаут) - выходим
				return
			}
		}
		// После отправки всех чисел канал oneChan закроется через defer
	}()

	// 2: ОБРАБОТЧИК (читает из первого, пишет во второй)
	go func() {
		// Гарантируем закрытие канала при выходе из горутины
		defer close(doubleChan)

		// range по каналу читает значения до тех пор, пока канал не закроется
		// Это удобный способ обработки всех входящих данных
		for val := range oneChan {
			// Аналогично используем select для неблокирующей отправки
			select {
			case doubleChan <- val * 2: // Умножаем на 2 и отправляем дальше
			case <-ctx.Done(): // Если контекст отменен - выходим
				return
			}
		}
		// Когда oneChan закроется, цикл for закончится
		// и doubleChan закроется через defer
	}()

	// 3: ВЫВОД (читает из второго канала и печатает)
	go func() {
		// Гарантируем отправку сигнала завершения
		defer close(done)

		// Читаем все обработанные числа из doubleChan
		for num := range doubleChan {
			// Выводим результат в стандартный вывод
			fmt.Println(num)
		}

		// Это сообщение выведется после обработки ВСЕХ чисел
		fmt.Println("Все данные выведены!")
		// После этого канал done закроется через defer
	}()

	// Ожидаем завершения программы одним из двух способов:
	select {
	case <-done:
		// Нормальное завершение: все данные обработаны и выведены
		fmt.Println("Программа успешно завершена")

	case <-ctx.Done():
		// Аварийное завершение: сработал таймаут (5 секунд)
		fmt.Println("Программа завершена по таймауту")
	}

	// Здесь выполнится defer cancel() для очистки ресурсов контекста
}
